\chapter{Post-Conclusion}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CHAPTER

\section{Personal Motivation}
During my internship I was tasked with creating a parametric 3D CAD model. 

- local usage 
  -> quick, direct feedback

- We needed to make this a product for end users. 

- Industry-standard choice: cloud 
  -> smart-server dumb-client setup, cloud-native architecture 

- Problems
  -> continuously downloading new resulting CAD files after every change created a lot of web traffic. 
  -> slow, not at all the same experience.
  -> cloud host was even more slow in cold-start scenario's   
  -> cloud host monetization scheme: pay for every time the script runs, 
     -> meant that consumers had to be discouraged to 'play around' with the tool too much. 
  
This made me question the cloud-native paradigm, at least for the use case of calculating geometry by end users. 


if the data is geodata or CAD data, does not matter besides the fact that geodata is often big data.


\section{On the future}


\section{Auxiliary Objectives}

\subsection*{Fair Geodata \emph{Processing}}
-> OGC: Fair Geodata
\m{->} FME : data integration tool
\m{->} Grasshopper: 3D CAD: visually creating and debugging geometries
       L \m{->} Used within the field of AEC for solar analysis, routing, permit checks.
These visual programming environments 
Due to this need for [X], the goal of this thesis is to develop a method for geo-computation in a browser-based front-end. 


\subsection*{Explore Web Capabilities }

- HTML5 with WebGL and Canvas Api -> Celsium, Leaflet, D3
- javascript runtime improvements -> shift from backend-heavy to frontend-heavy web applications
- http range request -> cloud native geospatial movement 
- WebAssembly -> ...

WebAssembly is a potentially revolutionary technology. We don't know yet what it fully means or what it can do, so we should explore.


Many things where discovered as side effects of the main goal of this thesis. We wish to discuss these other aspects here.

\subsection{Improvements to FME \& grasshopper}
If this study would have stated to create a FOSS, web based alternative to FME or Grasshopper, that would perhaps be enough to base a thesis on.

-> FME: run scripts on the server 
-> Grasshopper: (industry sollutions) Shapediver, White Lioness, 

-> The fun thing is that GeoFront has been created with this perspective from scratch. This could lead to a much more clean implementation

\subsection{FAIR geodata \emph{Processing} by using browser-based, front-end geo-computation}



\subsection{Exploring WebAssembly}

\subsection{Exploring Client-side geo-computation}


\subsection{Notes}


/ experiment to assess: 
- The fitness of the web in general for client-side geo-computation
- If new features of modern browsers mean anything for the field of geo-informatics at large 
- The topic of accessible geoprocessing.

now, answer this to the best of your ability

Many considerations

% Premature optimization is the root of all evil | Donald Knuth
% Delay decisions to the latest moments, to gain maximum context,
% Key insight into writing better compilers

While conducting this research, I came across various key insights from various studies, and there seemed to be a link between them 

Most important effort I saw is the "denichification" of the geospatial world.
- Hugo's keynote
- Linda van den Brink's PHD
- cloud-native geospatial 



\section{FAIR}

observation: 
- a lot of attention for FAIR geodata, linking of geodata, using common standards, etc. 

BUT: We don't seem to put as much emphasis on FAIR geodata \emph{Processing}. 
- The means to filter a dataset, to process it or convert it to a required format or CRS, could become more FAIR

We focus on Accessibility
accessibility

\m{->} the fact of being able to be reached or obtained easily:
\textit{Two new roads are being built to increase accessibility to the town centre.}

\m{->} the quality of being easy to understand: 
\textit{The accessibility of her plays means that she is able to reach a wide audience.}

...

- The front-end browser technologies are a vital component of the modern geospatial software.
- Like how the entire cloud-native moment is only possible because of the HTTP range request feature. 


THE MAIN THING I WOULD LIKE YOU TO GET AWAY FROM ALL OF THIS:
- a vital component of the cloud-native geospatial moment is the "HTTP range request" web feature, and chris said as much.
  - this feature has been out for some time ( html1/1, )
- What I'm saying, is that we have a whole range of similar, 'game changing technologies' recently added to web browsers, and I have a feeling these features could be the birthing grounds for new, ground breaking ideas and movements of ideas. 

We have not fully envisioned these new trends, nor do we have a catchy, powerful name such as \emph{Cloud Native Geospatial}, But I have no doubt that something revolutionary will come of this. 

Nevertheless, I will attempt to name and envision a trend from these technologies. \emph{"FAIR Geodata Processing"}.

Vision: 
- Portable, cross-platform, binary geoprocessing libraries, which can be used on the cloud / on servers, natively, and in the browser, without any changes. 
\m{->} we can use that to build standards for geodata processing itself. Every \m{GP} library interoperable with every other library, at least on a language and package manager level.
- This also eliminates the need of platform specific plugins (QGIS plugins, ARCGIS plugins, Blender Plugins, 'web plugins').
- This could lead to a generalized geoprocessing library portal like NPM / cargo / WAPM with an attached content delivery network, Or these infrastructures can just be utilized, with just an UI sprayed on top.

- I am aware that these types of efforts have been attempted many times before, but WebAssembly might be a missing link 

\m{->} webassembly has a good balance between portability and performance.

\m{->}

If I were to attempt to name this trend, I would









\subsection{Use Cases of Browser Based Geoprocessing}



- For which use-cases might such an application be beneficial? (~Old Phase 4)
- Name all reasons for browser based geoprocessing, and the 4 audiences.

Discuss 

\section{Reproducibility}
% This chapter explains how this thesis might be reproduced, as well as 

Reproducibility
Results themselves are insanely reproducable.
Software can be used, you can reproduce results easely by dumping versions of geofront in 
a folder.

\dots

Software can also be build without too many difficulties, but the procedure has some unconventional build steps: 

\dots

BUT, the code is not the cleanest, nor the most conventional. minus points on open-source accessibility.



\subsection{Environment}%%%%%%%%%%% SECTION
- github organization 
- repo for engine 
- repo for app 
- repo for each plugin
- build procedure

\subsection{Usage}%%%%%%%%%%% SECTION

\emph{basically, write a tutorial}

This is how one can use Geofront

\subsection{Creating \& Using your own code}
\emph{show the insane (rust + wasm + npm) workflow}

Locally: 
1. Write a geoprocessing / analysis library using a system-level language (rust, C++).
2. Expose certain functions as public, using 'wasm-pack' or 'emscripten'.
3. Compile to `.wasm` + `d.ts` + `.js`.
4. publish to npm (very easy to do with wasm-pack, can also be done with emscripten)

Alternatively: 
1. Write a library using typescript, 
3. Compile to `d.ts` + `.js`.
4. publish to npm 

In Geofront: 
4. Reference the CDN (content delivery network) address of this node package. 

Congrats, this is now a publicly accessible geofront plugin!
The library is loaded, A component is created for each function, with inputs for input parameters, and a singular output. If a 'typescript tuple type' is exported, the plugin loader will create multiple outputs according to each component of the tuple.

\section{Limitations}%%%%%%%%%%% SECTION

Limitations of usage right now



\section{Future Work}
Boulevard of broken dreams :) 

This thesis has only scratched the surface of all that

- Geofront as web-based version of grasshopper
- Geofront as lightweight QGIS replacement 





\subsection{App Features}

\subsubsection{ Constrain plugin support}
- Its becoming too hard to cater to both. The more constraint plugin support becomes, the more powerful and well-integrated we can make the plugins
- It would be really nice to make rust the only way of creating plugins. 
- Build a separate plugin loader for C / C++, or only support those through C++ bindings (dont know if wasm-pack can handle C bindings)


\subsubsection{Adding first-class type support to plugin types, by creating a Rust crate }
We couldn't do this, because we wanted to cater to .ts, .js and C++- based plugins.