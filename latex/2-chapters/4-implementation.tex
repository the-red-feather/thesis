\chapter{Implementation}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CHAPTER

\section{Software Architecture}
% Explain main code setup \& components
GeoFront exists as a series of loosely coupled repositories, all published on the version control platform GitHub under the MIT license. These repositories are grouped under the GitHub Organization \verb|thegeofront| : https://github.com/thegeofront .
The \verb|app| repository holds the main GeoFront application. It contains the source code for most aspects, such as the basic UI, the visual programming interface, and the standard components. 
The \verb|engine| repository is the library used for the 3D visualizations, some of the logic within the graph components, and some helper functions.
The \verb|GeoFront| organization also contains several repositories which are loaded as plugins, such as the wasm-bindings for startin.

\section{Engine}
The \verb|Engine| is a typescript library 

It can be used both as a header-only library, or it can be compiled to a normal javascript module. 
Header only is an unusual 

- Various functionalities, not only created for GeoFront.
- A custom engine was used, so it could be specialized to the needs of geoprocessing. 
- Three.js inspired, but very strip-down

\section{App}
GeoFront is set up as a \verb|TypeScript| project. It uses \verb|webpack| to compile the typescript 

\subsection{Web Framework}
Every web application requires some amount of html and css to make up its content, and GeoFront is no exception. 



- No Framework
- Web Components
- Typesave Events
- Webpack + Typescript

"...
WebComponents have not been used just as a curiosity. 
The Graph is intended as a sequence of containerized processes, 
which whould match WebComponents containerized nature perfectly, just like it matches WebAssembly
..."


\subsection{Menu}
with these html components, the basics of the webapp can be created: menu's side menu, and the two main canvases: the graph canvas, and the viewer canvas 
% _explain the file / edit / view / side menu setup_  (Because of Design rule 1. Model after normal application )
GeoFront's use-case is, however, slightly different. We wish to use html as a type of IMGUI. 


\section{The Graph}
\emph{explain how to create a visual programming language}
\subsubsection*{Graph representation}
  - Map `Functions` to `Nodes` 
  - Map `Variables` to `Edges / Cables`
\subsubsection*{Graph manipulation}
  - Canvas 2d API
  - Event-driven
\subsubsection*{Graph calculation}
  - Dag
  - Dynamic recalculation 

\subsection{Viewer}
\emph{explain how the viewer was created from scratch}

lightweight three.js clone

supports basic things

fast, due to direct buffer types

\subsection{ Plugin Loader } 

\emph{explain the system to dynamically load plugins at runtime}

\subsubsection{ Type System }

\emph{explain how data is exchanged, and objects are handled (lazy tools)}
- Functional programming (exchange structs)

\subsection{ Standard Library }

The standard library is a 'baked in plugin'.
Points, lines, triangles, vectors, etc.

\subsection{ Plugins }
What does a plugin need in order to be acceptable
one javascript file, one type definitions file, and one optional wasm file are accepted. 

ts -> normal build works out of the box
rust -> wasm pack compile target web -> works out of the box 
c++ -> emscripten -> more manual work needed 

\subsubsection{Features}
- IO can use:
  - basic types (boolean / number / string)
  - jsons, objects, interfaces (typesystem will pick up on them)
  - ArrayBuffers (vital for performant data transfer)



% ## WebAssembly Plugins

% _explain how to use webassembly_
% - compiling
% - getting data within webassembly
% - extracting webassembly
% - how to deal with objects? 


\subsubsection{ Startin }
- web assembly based

\subsubsection{ CGAL }




\section{Achieved Functionality}



...




