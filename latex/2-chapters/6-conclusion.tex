% repeat results and answers in shortened form
\chapter{Conclusion}
\label{chap:conclusion}
In this study we described the ...

In this study, the main research question was determined as: \myMainRQ
sub-questions were defined, which will be answered in the following paragraphs.

% In this article we described the design, creation and evaluation of GeoFront, a web-based point-cloud processing tool.

% Overall, the study has succeeded in what it set out to do: designing and implementing a geo-web-vpl. 

% Moreover, it has delivered an incremental workflow which can be used to quickly configure existing, native geoprocessing libraries written in C++ or Rust to be consumed and used by said geo-web-vpl.  

% However, the usefulness as a fully-featured geo-computation tool is limited. 

% The usefulness and 

% This study concludes that based on these measurements, browser-based geo-computation  is fast enough that it can enable 

% many promising use-cases, such as on-demand geodata processing apps, educational demo apps, and code sharing. 

% However, extensive user-group testing is required before any definitive statements on accessibility and fitness for geo-computation can be made.  




% \dots

% supprising what was hard, what was easy. 


% With GeoFront, geoprocessing flowcharts can be created, shared and run from within a web browser.  
% The full application runs front-end in a browser, and both end results and intermediate products can be inspected in a 3D viewer.

% The tool offers functionalities such as point cloud loading, triangulation, and isocurve extraction.
% These functionalities can be expanded upon though a plugin system which utilizes the existing "Node Package Manager" infrastructure and WebAssembly.
% By using both, industry standard geoprocessing libraries such as `CGAL`, `GDAL` and `PROJ`, and data parsing libraries such as `IFC.js` and `laz-rs`, can be utilized.

% In addition to the goal of examining wasm-based geo-computation, the auxiliary goal of this thesis is to make geoprocessing more accessible. 
% By being free and open source, usable in a browser, and by focussing on the integration of existing geoprocessing libraries, GeoFront attempts to be more in line with the wider vision of cloud-native Geospatial than visual geo-computation environments, like FME or Grasshopper. 
% This is done to be in line with the aforementioned cloud native vision of eventually allowing non-expert usage of GIS.


% (I must figure out how to frame this thesis more compactly. I must focus on a smaller aspect of geofront than the totality of it.)

% By creating geofront, this thesis was able to discover .............

% - advantages: 
%   - The web **is** able to facilitate a visual programming language.
%     - does indeed make excellent use of accessibility & interactivity aspect
%   - reasonable performance 
%     (- great considering the platform)

% - disadvantages: 
%   - all in-between data must be stored in memory if it is to be inspected.
%     - Can't make use of 'writing files', so that something can be removed from memory 
%     - BUT, even when using emscripten, you are still caching all sorts of things

%   - The web is able to be used for geoprocessing, albeit with some caveats
%     - Less control and precision
%     - TypedArrays,
%     - Geometric predicates 
%     - Rounding
%     - ETC.

%   - Many of these things can be fixed with webassembly, but webassembly itself has other shortcomings
%     - Differences between Rust & C++

%  - Notes:

%    - would not be possible without these modern web features
%     - Web Assembly 
%     - Typed Array's 
%     - Web Workers
%     - Web Components,
%     - 2D Canvas API
%     - Web GL

% - ability to share is a true enhancement

\section{Answers}

\subsection*{Sub Questions}

\begin{itemize}[ ]
  \item \emph{\mySubRQOneTitle:} "\mySubRQOne"
\end{itemize}

la la la

\begin{itemize}[ ]
  \item \emph{\mySubRQTwoTitle:} "\mySubRQTwo"
\end{itemize}


\begin{itemize}[ ]
  \item \emph{\mySubRQThreeTitle:}  "\mySubRQThree"
\end{itemize}

la la la

\begin{itemize}[ ]
  \item \emph{\mySubRQFourTitle:} "\mySubRQFour"
\end{itemize}

la la la

% X : wasm-based geo-computation applications

CITYJSON VALIDATOR ARGUMENT: THE WEB CAN BE USED TO IMMEDIATELY MAKE SOME TOOL / SOME RESEARCH PROJECT OPERATIONAL 'IN THE REAL WORLD'. THIS WAY, DATA CAN BE GATHERED, USER FEEDBACK CAN BE GATHERED, AND THE TOOL CAN BE EVALUATED IN TERMS OF REPRODUCABILITY. FINALLY, IT OFFERS THE POSSIBILITY OF THE TOOL BEING ACTUALLY USED, IN PRACTICE. 
z

\subsection*{Main Question}

\begin{itemize}[ ]
    \item "\myMainRQ"
\end{itemize}

The full design and implementation are represented by \refchap{chap:methodology} and \refchap{chap:implementation}. 
But to summarize:

[make a final conclusion based upon the 4 sub-answers above]

we split up this study into four sub-studies, each defining, analysing and overcoming a specific challenge of the implementation of a \ac{geo-web-vpl}.

In first sub-study, 

the study explained the challenges and solutions concerned with developing the prototype Web 3D VPL Geofront.
- the challenge of simulating a native interface and experience in a web browser. 
- Especially file system challenges 

In the second sub-study,

challenge: 
compilation to wasm

Observation: 
C++ is difficult to compile to wasm.
This is not due to wasm itself, but rather the focus of emscriptem in compilation of full C++ applications, and the emulation of a POSIX environment in a web browser. 
The library support lacks ergonomics.
The library support of rust is more advanced.

Conclusion: 
Rust is for the forseeable future a better choice for writing platform-independent libraries. 
Suggestion: Emscripten's 'embind' tool to expand to the level of 'wasm-bindgen'.

Third sub-study: 

Challenge:
Two layers of wrapper libraries are needed to take an existing rust / C++ library, and run it in a web-based visual programming language.

This is why this third component of the methodology is focused on mitigating the need for the second wrapper library. 

solutions: 
- automatically base visual components on typescript header-files
- add any 'config' information to the first type of wrapper library. 

\section{Conclusion}

\begin{note}
  
- Where was this 'barrier'?
combination: 
1. hard to expose existing libraries in a way that is actually nice to use
- "just compiling to wasm" was not enough.
- Webassembly is a double edged sword. Interfacing with wasm binaries from javascript is slow: lots of duplication of data. 
-> this study leaned heavely on Rust to solve this problem

2. disconnect with regular programming libraries
- to turn a function into a component usable in a visual programming graph, lots of meta-data is needed. 
  -> leading to config files 
  -> leading to a barrier between regular programming libraries, and vpl libraries. 
  -> this study opted for automated configs based on 'typescipt' headers to attempt to solve this problem. This worked, but had some new Limitations
     -> it did allow for rapid experimentation, and seemless interoperability
     -> however, other aspects like descriptions, library meta info, etc. 
     -> for this a 'config' of some sorts was still needed. 

3. web interface
- Having no file system really hurts the usefulness of the vpl as a data processing application.

-> This study recommends cloud-native as a solution to this problem, and has added 


this study 



Does Geofront succeed in "converting existing geocomputation libraries to a sharable VPL format?" 

Yes: 
 - Using the environment, you can take a rust-based geo-computation function or library, 
   and without very many steps, use it within a visual programming environment. 
   The environment can then be used to:
   - Visually debug, 
   - Play around with parameters, 
   - Compare performance to similar libraries,
   - And, unique to this environment, do this all online, in a 'published' format: the full configuration can be shared using a URL. 

   The combination of these aspects makes this environment unique. 

- These libraries can be used with a minimum of configurations. Any Rust library with `wasm-bindgen` annotations, in other words, any rust library intended for javascript consumption, automatically works in 'geofront', albeit with some edge-case exceptions. 


No: 
 - While it is indeed possible to use and run any rust library with `wasm-bindgen` annotations, in order to properly communicate, visualize, and make data interoperable, special 'config' functions and methods are needed. 

 - For now, only 'Rust' and 'JavaScript / TypeScript' can be properly used as libraries. However, most libraries relevant to geo-computation are C++ based. While C++ has excellent support for compiling full, self contained applications to WebAssembly using the 'emscripten' toolset, it lacks rust's level of support in compiling existing libraries. `embind` can be used for this, but compilation using embind is a more tedious, error-prone process.   
   - Additionally, many scientificly oriented C++ libraries like CGAL make extensive use of meta programming and template programming. These ideas do not translate well to an environment outside of C++. 

 - the environment uses browser-based calculations, so it cannot be used properly for big data, or other expensive processes.
   Future work: compile the flowchart, run it headless on a server for large datasets.
 
 - the flowchart can only represent linear processes. Many geoprocessing algorithms are iterative and make use of conditionals. These cannot easily be expressed on the canvas. As such, these processes must happen within the context of a function, within a 'computational node'

\end{note}

\section{Limitations}

The qualitative and quantitative measurements have a degree of subjectivity
- research topic is sizable
- 

% ## Accessibility
% _"Is this environment truly accessible?"_


% ## Practical 
% _"Is this environment truly a competitor to native / other methods of geoprocessing?"_

% ## As Demo / Scripting Environment 
% _"Is this environment a good demo host?"_

\section{Discussion}
\label{sec:discussion}


\subsection{Q: Is a ac{geo-web-vpl} the same as a 3D vpl with existing geoprocessing functionalities attached? In other words, is geoprocessing nothing else than procedural modelling?}

A: No, but it is a good start. a geo-web-vpl is 'at the very least' a 3D vpl with geoprocessing functionalities. 
But, an actual geocomputation vpl might require more features, such as a global CRS, support of base-maps, more control on precision, etc. 
These nuances must be left for subsequent studies. 

\subsection{Q: Usage: Who benefits from a web-geo-vpl, and how? }
A web-based visual programming language for geocomputation as described by this study does not exist yet. 
This requires us to be clear about its intended use-case. 
However, because of this same novelty, a singular, definitive use-case can not be given.
This study proposes 4 use-cases:
\begin{enumerate}[-]
  \item Educational Sandbox
  \item Web Demo Environment
  \item End-user geoprocessing environment 
  \item Rapid prototyping environment
\end{enumerate}

...

% To solve this problem, this study names four possible use-cases.  
% These cases are not mutually exclusive, but will be judged separately, based on specific criteria 
% During assessment, we will use these four profiles and accompanying criteria to judge how well the geo-web-vpl meets up this use-case.


% \subsection*{Case 1: Educational Sandbox}

% "
% insight within these processes are vital for communication, voor 'overdracht' 
% the 'jonathan blow educational argument' 
% "

% - This use-case can be fully realized within the current state of geofront
% - "Geoprocessing for kids"
% - "What is a delaunay triangulation?" 
% - "Let people play / experience / traverse a nef polyhedron"
% - Using something helps with understanding

% \subsection*{Case 2: Web Demo Environment}
% % # A: 1. Geofront as a geoprocessing / analysis demo tool.
% % - Frame Geofront as an expanded version of https://validator.cityjson.org/ this. 
% %   - [this](https://validator.cityjson.org/) (a wasm web demo) + jsfiddle 
% %   - Use rust, web, and c++ tools side by side, hand in hand

% - Reproducibility toolkit:
% - Workflow: 
%   - Load your own code from a CDN
%   - Build a demo setup around it
%   - load a custom graph from a public json file
%   - share a url pointing to this json (which contains the CDN address)
% - You can now share a rust / C++ program as a fully usable web demo,   
%   and analyze its performance using different datasets, test parameters, etc. 
% - interdisciplinary exchange of ideas
% - MISSING FEATURE: dependency list inside of the graph.json save file

% Within the field of geo-informatics, we want to share our end-results. 
% - Usually on git, but this has limitations:
%     - Not everybody can immediately use it ( unfamiliar language / build system),
%     - Even people who can understand, often wont go through the trouble.  
%     - "Python bindings" -> half-solves the problem, but still hard to publish to a general audience. 

% This was the exact reason for developing https://validator.cityjson.org/. This solved the issue of publication. Why? 
% - Extremely findable, usable, accessible
%   - Cross-platform
%   - No install 
%   - first point of contact is precisely where you can use it
%   - You can send a link not to a download page, but to the application itself
%   - Great for communication: blogs with embedded applications.
%   - Code sharing: you exactly know what to expect.

% \subsection*{Case 3: End User Geoprocessing Environment}
% - Lightweight FME, but open source \& on the web.
% - The tool in itself can be regarded as an end-user application:
%   - Load file, do something with the file, download resulting file
%   - REQUIRES WAY MORE SUPPORTING LIBRARIES AND TOOLS
% - Flowcharts can be exchanged by means of url's.
% - Future work: export flowchart to a process which can be run natively or server side.
  

% \subsection*{Case 4: Rapid-Prototyping Environment}
% \begin{lstlisting}
% - Web geoflow
% - To be used within a regular software development process.
% - Ravi's GeoFlow, but on the web
% - Meant to visually debug a certain process, after which this process can be 'compiled' to a normal cli tool.


%   WHY: 
%   - all three the previous use-cases combined: demo, test, educate yourself
%     on your own algorithms, then operationalize the code to use it in a 
%     serious environment.  
% \end{lstlisting}


% we are not the first to recognize the suitability of the web for publishing demo's

% We see a lot of interactive web-demo's nowadays, and many of them are embedded within a type of "Demo Hosts":

% - Scripting environments in (Science) Communication:
%   - Jupyter Notebook 
%   - Observable
%   - JsFiddle
%   - Shadertoy
%   - Wapm

% - Scripting environments in Education: 
%   - TU Delft C++ course
%   - Udemy

% - Scripting environments in Tutorials: 
%   - Rust
%   - Lit

%   <!-- - (game-jam games)
%       - more save (no virus) -->

% <!-- We also see 

% - As accessible alternative to native
%   - Overleaf -> does not use webassembly, but a classic client-server architecture
%   - Google Earth -->

% All these applications lie on a crossroad between being an interactive demonstration of a certain result or phenomenon, 
% and an open invitation for the user to edit and use this result or phenomenon. 
% (CITE A STUDY PROVING HOW INTERACTION BENEFITS LEARNING), 
% so toying around is important.

% <!-- So it is save to say the web is suitable for these types of things. 
% But is the web also suitable for more? Can we use a web-based sandbox environment to -->


% we want to examine and edit the geodata flow, see for example, where these errors occur, try to get to that data, see if we can make hotfixes, etc. etc. 

