% repeat results and answers in shortened form
\chapter{Conclusion}
\label{chap:conclusion}
In this study we described the ...

In this study, the main research question was determined as: \myMainRQ
sub-questions were defined, which will be answered in the following paragraphs.

% In this article we described the design, creation and evaluation of GeoFront, a web-based point-cloud processing tool.

% Overall, the study has succeeded in what it set out to do: designing and implementing a geo-web-vpl. 

% Moreover, it has delivered an incremental workflow which can be used to quickly configure existing, native geoprocessing libraries written in C++ or Rust to be consumed and used by said geo-web-vpl.  

% However, the usefulness as a fully-featured geo-computation tool is limited. 

% The usefulness and 

% This study concludes that based on these measurements, browser-based geo-computation  is fast enough that it can enable 

% many promising use-cases, such as on-demand geodata processing apps, educational demo apps, and code sharing. 

% However, extensive user-group testing is required before any definitive statements on accessibility and fitness for geo-computation can be made.  




% \dots

% supprising what was hard, what was easy. 


% With GeoFront, geoprocessing flowcharts can be created, shared and run from within a web browser.  
% The full application runs front-end in a browser, and both end results and intermediate products can be inspected in a 3D viewer.

% The tool offers functionalities such as point cloud loading, triangulation, and isocurve extraction.
% These functionalities can be expanded upon though a plugin system which utilizes the existing "Node Package Manager" infrastructure and WebAssembly.
% By using both, industry standard geoprocessing libraries such as `CGAL`, `GDAL` and `PROJ`, and data parsing libraries such as `IFC.js` and `laz-rs`, can be utilized.

% In addition to the goal of examining wasm-based geo-computation, the auxiliary goal of this thesis is to make geoprocessing more accessible. 
% By being free and open source, usable in a browser, and by focussing on the integration of existing geoprocessing libraries, GeoFront attempts to be more in line with the wider vision of cloud-native Geospatial than visual geo-computation environments, like FME or Grasshopper. 
% This is done to be in line with the aforementioned cloud native vision of eventually allowing non-expert usage of GIS.


% (I must figure out how to frame this thesis more compactly. I must focus on a smaller aspect of geofront than the totality of it.)

% By creating geofront, this thesis was able to discover .............

% - advantages: 
%   - The web **is** able to facilitate a visual programming language.
%     - does indeed make excellent use of accessibility & interactivity aspect
%   - reasonable performance 
%     (- great considering the platform)

% - disadvantages: 
%   - all in-between data must be stored in memory if it is to be inspected.
%     - Can't make use of 'writing files', so that something can be removed from memory 
%     - BUT, even when using emscripten, you are still caching all sorts of things

%   - The web is able to be used for geoprocessing, albeit with some caveats
%     - Less control and precision
%     - TypedArrays,
%     - Geometric predicates 
%     - Rounding
%     - ETC.

%   - Many of these things can be fixed with webassembly, but webassembly itself has other shortcomings
%     - Differences between Rust & C++

%  - Notes:

%    - would not be possible without these modern web features
%     - Web Assembly 
%     - Typed Array's 
%     - Web Workers
%     - Web Components,
%     - 2D Canvas API
%     - Web GL

% - ability to share is a true enhancement

\section{Answers}

\subsection*{Sub Questions}

\begin{itemize}[ ]
  \item \emph{\mySubRQOneTitle:} "\mySubRQOne"
\end{itemize}

la la la

\begin{itemize}[ ]
  \item \emph{\mySubRQTwoTitle:} "\mySubRQTwo"
\end{itemize}


\begin{itemize}[ ]
  \item \emph{\mySubRQThreeTitle:}  "\mySubRQThree"
\end{itemize}

la la la

\begin{itemize}[ ]
  \item \emph{\mySubRQFourTitle:} "\mySubRQFour"
\end{itemize}

la la la



\subsection*{Main Question}

\begin{itemize}[ ]
    \item "\myMainRQ"
\end{itemize}

The full design and implementation are represented by \refchap{chap:methodology} and \refchap{chap:implementation}. 
But to summarize:

[make a final conclusion based upon the 4 sub-answers above]

we split up this study into four sub-studies, each defining, analysing and overcoming a specific challenge of the implementation of a \ac{geo-web-vpl}.

In first sub-study, 

the study explained the challenges and solutions concerned with developing the prototype Web 3D VPL Geofront.
- the challenge of simulating a native interface and experience in a web browser. 
- Especially file system challenges 

In the second sub-study,

challenge: 
compilation to wasm

Observation: 
C++ is difficult to compile to wasm.
This is not due to wasm itself, but rather the focus of emscriptem in compilation of full C++ applications, and the emulation of a POSIX environment in a web browser. 
The library support lacks ergonomics.
The library support of rust is more advanced.

Conclusion: 
Rust is for the forseeable future a better choice for writing platform-independent libraries. 
Suggestion: Emscripten's 'embind' tool to expand to the level of 'wasm-bindgen'.

Third sub-study: 

Challenge:
Two layers of wrapper libraries are needed to take an existing rust / C++ library, and run it in a web-based visual programming language.

This is why this third component of the methodology is focused on mitigating the need for the second wrapper library. 

solutions: 
- automatically base visual components on typescript header-files
- add any 'config' information to the first type of wrapper library. 

\section{Conclusion}

- Where was this 'barrier'?
combination: 
1. hard to expose existing libraries in a way that is actually nice to use
- "just compiling to wasm" was not enough.
- Webassembly is a double edged sword. Interfacing with wasm binaries from javascript is slow: lots of duplication of data. 
-> this study leaned heavely on Rust to solve this problem

2. disconnect with regular programming libraries
- to turn a function into a component usable in a visual programming graph, lots of meta-data is needed. 
  -> leading to config files 
  -> leading to a barrier between regular programming libraries, and vpl libraries. 
  -> this study opted for automated configs based on 'typescipt' headers to attempt to solve this problem. This worked, but had some new Limitations
     -> it did allow for rapid experimentation, and seemless interoperability
     -> however, other aspects like descriptions, library meta info, etc. 
     -> for this a 'config' of some sorts was still needed. 

3. web interface
- Having no file system really hurts the usefulness of the vpl as a data processing application.

-> This study recommends cloud-native as a solution to this problem, and has added 


this study 


\section{Limitations}

The qualitative and quantitative measurements have a degree of subjectivity
- research topic is sizable
- 

% ## Accessibility
% _"Is this environment truly accessible?"_


% ## Practical 
% _"Is this environment truly a competitor to native / other methods of geoprocessing?"_

% ## As Demo / Scripting Environment 
% _"Is this environment a good demo host?"_

\section{Discussion}
\label{sec:discussion}


\subsection{Q: Is a ac{geo-web-vpl} the same as a 3D vpl with existing geoprocessing functionalities attached? In other words, is geoprocessing nothing else than procedural modelling?}

A: No, but it is a good start. a geo-web-vpl is 'at the very least' a 3D vpl with geoprocessing functionalities. 
But, an actual geocomputation vpl might require more features, such as a global CRS, support of base-maps, more control on precision, etc. 
These nuances must be left for subsequent studies. 