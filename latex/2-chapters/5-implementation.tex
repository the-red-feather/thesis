\chapter{Implementation}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\label{chap:implementation}
This section presents the implementation details of the first and second step of the methodology. 

\section{The Geofront Application}

\begin{note}
  todo: rewrite everything to make sense! 
\end{note}

\begin{figure}
  \centering
  \graphicspath{ {../../assets/images/implementation/} }
  \includegraphics[width=\linewidth]{full-application.png}
  \caption[Geofront]{The Geofront Application}
  \label{fig:geofront-app}
\end{figure}

\begin{note}
  [Stelios]  Where you describe the implementation I made a comment about you mentioning git(hub) too much. Imo, git(hub) is just the place where you store the code, but the structure of your code and everything around the implementation is only independent from the version control system that you use. We normally just leave a sentence about this, stating that the code is available as open source in a repository. But because you have the organization and the multiple repos, maybe you can have a small paragraph about that summarizing this. But don't mix this with the actual discussion about implementation.

  [Ken] division between 4 and 5 is weird, 4 feels empty and 5 where the actual content is  feels like 5 doesn't actually implement the methodology of 4, but instead follows the actual logic of the Code
  
\end{note}

This section explains the significant components of this prototype application. 
The prototype is titled "Geofront", as a concatenation of "geometry" and "frontend".
Geofront exists as a set of loosely coupled repositories, all published on the version control platform GitHub under the MIT license. These repositories are grouped under the GitHub Organization \m{thegeofront} (SOURCE: https://github.com/thegeofront).

The Geofront Application (\m{app}) is implemented according to the design layed out in \refchap{chap:methodology}.
It is implemented using \m{TypeScript}. 
\m{webpack} is used to compile this codebase into a singular javascript file, and this file practically serves as the full application. 
the repository spend around 9.000 lines of code, divided into core categories and functionalities.
What follows is a clarification of the implementation of some of these categories.

\subsubsection*{Rendering}

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.30\linewidth}
    \graphicspath{ {../../assets/images/implementation/} }
    \centering
    \includegraphics[width=\linewidth]{node.png}
    \caption{}\label{fig:node-cable:1}
  \end{subfigure}%
  \qquad 
  \begin{subfigure}[b]{0.30\linewidth}
    \graphicspath{ {../../assets/images/implementation/} }
    \centering
    \includegraphics[width=\linewidth]{cable.png}
    \caption{}\label{fig:node-cable:2}
  \end{subfigure}%
  \qquad 
  \begin{subfigure}[b]{0.30\linewidth}
    \graphicspath{ {../../assets/images/implementation/} }
    \centering
    \includegraphics[width=\linewidth]{widgets.png}
    \caption{}\label{fig:node-cable:3}
  \end{subfigure}%
  \caption[Nodes, Widgets and Cables]{The basic canvas components of Geofront: a Node (A), a Cable (B), and some Widgets (C) }
  \label{fig:node-cable}
\end{figure}

This nodes data model must be rendered to the screen so users can comprehend and edit the graph. 
This visualization is achieved by using the SOURCE: \href{https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API}{HTML5 Canvas Api}. 
The Canvas API is a raster-based drawing tool, offering an easy to use, high-level api to draw 2D shapes such as lines, squares, circles, and polygons. 
The Nodes Canvas uses this API to draw polylines and polygons at runtime, to represent the cables and nodes respectively. 
These basic shapes and their styles change dynamically, based on features like the length of a cable, how many input sockets a node requires, or whether or not a node is selected. 

Like other HTML5 features, the main advantage is that this API is included and implemented within the browser itself. This method is fast thanks to its C++ based implementation, and can be used without the need to include anything within the source code of the application.

The disadvantage of the Canvas API is that it uses many CPU-based draw calls. it is primarily CPU based, 
making it much less fast and efficient than WebGL for instance, which is based on the GPU. 
This is quickly noticeable within interactive applications which need to redraw often, such as Geofront. 
The Canvas is refreshed and redrawn often, and does not distinguish between unchanged and changed features. 
This comes down to a performance linear to the amount of nodes and cables drawn. For the current implementation and scale of Geofront, this performance is acceptable. 

\subsubsection*{Style}

\begin{figure}
  \centering
  \graphicspath{ {../../assets/images/implementation/} }
  \includegraphics[width=\linewidth]{a-full-graph.png}
  \caption[Shim Classes]{A complete Geofront Script}
  \label{fig:a-full-graph}
\end{figure}

Special care has been put into the stylization of the graph.
The visuals take inspiration from various geometry VPLS, such as Blender's GeometryNodes, McNeel's Grasshopper, and Ravi Peter's GeoFlow (SOURCES). 
A few notable exceptions, however. 
Firstly, the entire graph is placed on a grid, and all nodes strictly adhere to this grid (see \reffig{fig:a-full-graph}). 
For example, a node with three inputs will always occupy three grid cells in height. 
This grid is applied for much of the same reason as terminals \& source code are displayed using monospaced fonts. 
Consistent sizing encourages organization and clarity, for this makes it easy for components to line up, and predict how much space something requires.  
Cables also adhere to the grid. They alter their shape in such a way to remain as octagonal as possible, in an attempt to make connections between nodes more readable.
This takes some additional inspiration from subway maps, as well as the design of computer chips. 
This makes for a good fit, as these spatial configurations and the Geofront Script are all focussed on organizing connectivity.

\subsubsection{Interaction}
User Interaction is made possible through the \href{https://developer.mozilla.org/en-US/docs/web/api/event}{HTML DOM Events}. 
This api provides ways to listen to many events, including keyboard and mouse events. 
When the mouse is moved, its screen-space position is transformed to a grid position, which allows the user to select one or multiple objects. 

Geofront's user interface strives to match features of regular desktop applications. 
As such, the Geofront Graph supports features like undoing, redoing, duplication, copying, and pasting. 
These functionalities can be used with the expected keyboard combinations (Ctrl + C / Ctrl + V).

% \subsection{V. Menu}
% Web Framework

% Every web application requires some amount of html and css to make up its content, and \geofront{} is no exception. 

% \m{html} 

% - No Framework
% - Web Components
% - Typesave Events -> needed, because of the Lapsed listener problem.
% - Webpack + Typescript

% "...
% WebComponents have not been used just as a curiosity. 
% The Graph is intended as a sequence of containerized processes, 
% which whould match WebComponents containerized nature perfectly, just like it matches WebAssembly
% ..."

% with these html components, the basics of the webapp can be created: menu's side menu, and the two main canvases: the graph canvas, and the viewer canvas 
% \geofront{}s use-case is, however, slightly different. We wish to use html as a type of IMGUI. Several cur

\subsection{3D Viewer}

\begin{figure}
  \centering
  \graphicspath{ {../../assets/images/implementation/} }
  \includegraphics[width=\linewidth]{viewer.png}
  \caption[Geofront viewer]{The Geofront Viewer}
  \label{fig:geofront-viewer}
\end{figure}

The 3D viewer attached to the geofront application is also implemented in typescript. 
It is similar in architecture to the Three.js render engine (Source).
It uses WebGL and the OpenGL Shading Language (glsl) as its graphics API. 

The viewer can be used to represent and visualize various geometries, such as points, lines, meshes, bezier curves, and bezier surfaces.
Images can also be rendered, which are represented as a quad mesh with a texture. 

These visualization options open the possibility of visualizing a great number of different geodata types, such as DTM / DSM, GEOtiff, Point clouds, and OGC vector data. 

However, specific visualization convertors are not implemented, for these are reliant upon the compilation of existing geocomputation libraries. 

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.45\linewidth}
    \graphicspath{ {../../assets/images/implementation/} }
    \centering
    \includegraphics[width=\linewidth]{viewer-2.png}
    \caption{}\label{fig:viewer-geometries:1}
  \end{subfigure}%
  \qquad 
  \begin{subfigure}[b]{0.45\linewidth}
    \graphicspath{ {../../assets/images/implementation/} }
    \centering
    \includegraphics[width=\linewidth]{viewer-3.png}
    \caption{}\label{fig:viewer-geometries:2}
  \end{subfigure}%
  \caption[Geofront viewer geometries]{Some a bezier curve and surface visualized using the geofront viewer}
  \label{fig:viewer-geometries}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection*{The extent of the dataflow-VPL implementation}

\refsec{sec:method-one} named the following features which had to be implemented:
\begin{enumerate}[-]
  \item a base 'programming language model'
  \subitem A representation of the 'variables' and 'functions' of the language
  \subitem With all computations being pure functions
  \subitem With all variables being immutable
  \item a 'graph-like' visualization of this data model
  \item an interface to create and edit this graph 
  \item a way to provide input data 
  \item a way to execute the language
  \item a way to display or save output data
\end{enumerate}

\subsubsection*{The model}
A basic (visual) programming language model was able to be fully implemented on the web. 
No special web features were utilized in the creation of this model, despite HashMaps and HashSets offered by the Typescript language. 

\subsubsection*{Visualization}
Visualization of the graph is implemented using the 2D canvas api.  
On every registered change to the graph, the canvas is redrawn. 
The 2D canvas api makes use of explicit draw calls, rather than 'defining' some visualization, and leaving the render sequence to the renderer itself, like HTML.
This way, One does not have to first 'create' a circle object and pass it to a renderer. 
A circle can instantly and directly be drawn at the position specified.
The downside of this implementation, is that all features the HTML renderer normally accounts for, like picking, conditional styling, and performant rendering of repetitious elements, are lost.
These have to be re-implemented in javascript, which will never be as performant as the codebase of the browser engines themselves. 
This makes the visualization slow while rendering a large amount of components (See TODO). 

\begin{note}
  TODO Show a graph with performance considerations
\end{note}

This slowness can be blamed partially on the implementation, and partially on the browser. 
The browser does not offer the 'middle ground' between html-like rendering and 2D canvas-like rendering required for a visualization like the dataflow graph. 
Still, this implementation could have experimented more with a HTML + SVG based render method.

\subsubsection*{Editing}
Editing of the graph was made possible by the various events offered by the browser api. 
This allows the graph to be editable using the mouse. 
The graph even offers 'undo' and 'redo' operations, and even 'copy' / 'paste' clipboard actions, using common shortcuts. 
However, the implementation does lack touch \& mobile support.

In general, these editing features are complete, but there are a few caveats caused by the browser environment.
Namely, the browser has need of its own controls and shortcuts. 
For example, the right mouse button brings up the browser context, and the \m{Ctrl + W} shortcut closes a browser tab, which cannot be overwritten.
While there are some workarounds, these aspects make web applications more 'convoluted' to implement than would otherwise be ideal.

\subsubsection*{Execution}
Execution of the graph works as described, albeit with a major setback: execution does not run on a separate thread. 
This means that the interface freezes up during large calculations, and this is not acceptable. 

The reason for this is the difficulty in achieving concurrency in the browser. 
To create a thread, one has to instantiate a so called 'web worker' \emph{with} the actual source code included in a parameter. 
Not only is this unusual, it forces a codebase to create separate files per thread.
The dynamic nature in which some of Geofront dependencies are loaded made splitting up the codebase like this impossible, let alone using multiple threads for calculating each node.

\subsubsection*{Input and Output}
The base dataflow VPl component of Geofront support input and output UI elements, like sliders, buttons, and text fields.
These form special nodes on the canvas, called 'widgets'. 
The fact that the Geofront implementation opted for a 2D canvas-based visualization made it so HTML could not be used for these aspects, and all these features had to be created from scratch.


\subsection*{The extent of the geometry support implementation}

\refsec{sec:method-one} named the following features as a requirement for geometry support:
\begin{enumerate}[-]
  \item Type safety 
  \item A way to load or to create geometry data 
  \item A way to export geometry data
  \item A method to preview geometry data in 3D
  \item A standard set of geometric types and operations
\end{enumerate}

\subsubsection*{Type Safety}
Type safety was fully implemented by essentially creating a new 'layer' of types in typescript.
The type system can be extended by types found in Geofront Plugins.  
In theory, this can be used to prevent all incorrect type usage during creation of a Geofront Script.
In practice, to support iteration, some runtime type checking was still required. 

\subsubsection*{IO}
Files can be used as inputs and extracted as outputs using the 'file load' and 'file save' widgets. 
These files are then loaded as raw text or raw binary, which can be parsed by using a parser appropriate for that file type. 
The problem with this implementation, is that it requires a full file to be loaded into memory. 
Most native parsers make use of streaming to avoid this. 
There are ways of supporting incrementally reading files in a browser, but these methods are not supported by all browsers yet. 

\subsubsection*{Visualization}
Visualization of 3d data used throughout the graph is possible thanks to WebGL. 
The useful aspect of WebGL is the fact it does not have to be included within the source code of a program. 
WebGL supports all render demands basic, small-scale 3D geodata visualization might need, such as point clouds and DTMs.
large scale visualization is not possible, as the visualizer does not support idioms like frustum culling, or dynamic levels of detail. 

\subsubsection*{Standard Geometry \& Operations}
lastly, the browser and this implementation were able to support the models and operations required for basic 3D geometry, like points, lines, polygons, and meshes.
the "TypedArray" browser feature is used extensively to bypass the fact that javascript has limited type support.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\section{The binding system}
\label{sec:implementation:loading}

\subsection{Execution}

\begin{figure}
  \centering
  \graphicspath{ {../../assets/images/4/} }
  \includegraphics[width=\linewidth]{loading-trajectory.png}
  \caption[Loading Trajectory]{Loading Trajectories}
  \label{fig:loading-trajectory}
\end{figure}

\begin{note}

  This turned out to be a problem during preliminary studies.
  If a \ac{geo-web-vpl} wishes to use non-js libraries, it would mean that these libraries would have to be wrapped twice (see \reffig{fig:loading-trajectory} A): 
  Once to expose the native library to the web using the methods described at \refsec{sec:method-two},
  And once more to map the web library to the visual language. 
  While this is a possibility, in practice, two layers of wrappers are not acceptable in terms of a development workflow.
  This would be cumbersome, prone to errors, and hurting version control by having to synchronize between 4 software projects. 
  
  There is also a second reason for critically addressing the way plugins are loaded. 
  An observation was made from studying the existing geo-vpls in \refsec{sec:related-geovpl}:
  It seems that if a developer wants to create custom VPL components, they are required to write plugins very specific to that particular VPL.
  This means that practically, the library ecosystem of a VPL is entirely its own: 
  It is separated from the wider context of textual programming libraries. 
  End users are at the mercy of developers implementing their libraries in the dialect their particular VPL.
  Meanwhile, developers are forced to implement and support a multitude of wrapper libraries for VPL platforms.  
  
  In contrast, if the library loader of a VPL was able to directly utilize textual libraries, the barrier between vpl ecosystems and regular text-based libraries would cease to exist, benefiting both developers and end users. 
  It might even lower the barrier between visual and textual programming in general, making it easier for VPl end-users to adopt some forms of textual programming, and vice versa. 
  
\end{note}

\subsection{Achieved functionality}
A loaded library can now be used inside Geofront to create nodes on the canvas. 
These nodes have inputs connectors for each input argument, and output connectors per return value (Multiple outputs connectors are created from tuples). 

The result of this loader architecture, is that libraries can now be created which can be used by both Geofront and (web) applications in general:
Just one API is able to satisfy both.
This also means that Geofront can use the existing infrastructure of 'normal' javascript libraries, and that sometimes, Geofront can use a library which was never intended to be used in a visual manner. 

\begin{figure}
  \centering
  \graphicspath{ {../../assets/diagrams/} }
  % \includegraphics[width=\linewidth]{Model Proposal.png}
  \caption[]{TODO: show importer side-by-side}
  \label{fig:todo-1}
\end{figure}


\begin{figure}
  \centering
  \graphicspath{ {../../assets/diagrams/} }
  % \includegraphics[width=\linewidth]{Model Proposal.png}
  \caption[]{TODO: show more achieved functionality}
  \label{fig:todo-2}
\end{figure}

\subsection{Limitations}
\label{sec:implementation:loading:limits}

The plugin loader can technically load any javascript / typescript library. 
In practice, however, there are some limitations due to the specific implementation used:

\subsubsection*{Files}
Firstly, the current loader accepts only one Javascript file, and one Typescript Declaration file per library.
A library without a 'd.ts' declaration cannot be used. 
If additional files are used, such as \ac{wasm} files, these will have to be explicitly fetched and run by the javascript file. 
In practice, the abundance of javascript bundlers do not make this limitation a "dealbreaker", and also most \ac{wasm} compilers work in a manner compatible to these limitations.
Still, this does mean that not just any javascript library can be imported. 

\subsubsection*{Library Structure}
Secondly, while the loader does support namespaces and even classes, not all types of libraries and programming styles are supported. 
Functions using callbacks, complex types, or generics, cannot be properly loaded. 
Libraries utilizing "method chaining APIs" can be loaded, but are difficult to use as intended on the Geofront Canvas.
Also bear in mind that the loader does not perform any checks to see if the loaded library actually uses pure functions. 

\subsubsection*{Types}
The plugin loader can only load functions using acceptable input and output types. 
Not all input and output arguments translate well to the format of a dataflow VPL. 
The types may only include: 
\begin{itemize}
  \item basic javascript types (boolean / number / string)
  \item basic jsons (unnamed structs), objects, interfaces 
  \item javascript ArrayBuffers like \m{Float32Array} (vital for performant data transfer)
\end{itemize}
The typesystem of the plugin loader will pick up on types exposed by a library, and include them within the type safety system of Geofront. 

\subsubsection*{Supported languages}
Finally, not all languages are equally supported:

\begin{itemize}[-]
  \item \textbf{Javascript / Typescript}: 
    If the Javascript and Typescript files used adhere to the limitations mentioned above, the library can be used. 
    However, a bundler needs to be used to include all sub-dependencies of a library, as the Geofront loader does not load sub-dependencies currently. 

  \item \textbf{Rust}:
    Libraries compiled to webassembly using the "\m{wasm-bindgen}" work "out of the box" in most cases.
    \m{wasm-bindgen} is able to generate javascript wrapper bindings for a \ac{wasm} library, accompanied by TypeScript type definitions. 
    This wrapper handles type conversions. 
    
    However, rust libraries compiled to the web do require a initialization step. 
    As such, the loader now checks if the library looks like a Rust library, and if it does, it uses a slightly altered loading method.
  \item \textbf{C++}
    At the time of writing this study, the 'embind' compiler (explained in \refsec{sec:implementation:loading}) does not have an option to compile a typescript declaration file. 
    Additionally, the javascript generated to wrap the wasm binary is not a wrapper handling type conversions and memory safety like Rust. 
    Instead, it uses a custom architecture programmatically expose javascript wrapper functions one by one, and leaves it to the user of the library to deal with type conversions and memory safety. 
    
    These two aspects combined makes it so C++ cannot use Geofront's loader directly, and must use an additional in-between wrapper library.

  \item \textbf{Other languages}
    This study only experimented with Rust and C++ as non-js languages.
    While the loader's ability to work with WebAssembly is promising, additional testing is required before Geofront can claim to support any language. 
\end{itemize}

\subsection{Achieved Workflow}
% \emph{show the insane (rust + wasm + npm) workflow}

With all the above considerations in mind, the following workflow can now be used to create a Geofront Plugin, which, as explained, doubles as a normal javascript library. 
If Rust or C++ is used, this setup "triples" as also a native geoprocessing library.
The Geofront standard library is implemented using workflow with Rust.

\begin{lstlisting}
  
  Using Typescript: 
  1. Write a geoprocessing / analysis library using typescript, 
  2. Compile and bundle to a `d.ts` + `.js` file.
  3. publish to npm 

  Using Rust: 
  1. Write a geoprocessing / analysis library using rust
  2. Create a second library, which exposes a subset of this 
     library as 'functions usable on the web', using 'wasm-pack'.
  3. Compile to `.wasm` + `d.ts` + `.js`.
  4. publish to npm (`wasm-pack publish`)
  
  Using C++: 
  1. Write or find a C++ based geoprocessing / analysis library. 
  2. Create a second library, which exposes a subset of this 
     library as 'functions usable on the web', using 'emscripten'*.
  3. Compile to a `.wasm` and `.js` file using emscripten.
  4. Create a third 'js' library, which wraps the functionality* 
     exposed by empscripten
  5. Manually create a corresponding `d.ts` file
  6. Publish these to npm 

  ---------------------------------------------------------

  In Geofront: 
  4. Reference the CDN (content delivery network) address of this node package. 
  5. Use the library.

  * these parts contain many caveats, explained in Section 5.2

\end{lstlisting}

\begin{figure}
  \centering
  \graphicspath{ {../../assets/diagrams/} }
  % \includegraphics[width=\linewidth]{Model Proposal.png}
  \caption[]{TODO: show the achieved workflow visually}
  \label{fig:todo-more-images}
\end{figure}

\subsection{AGAIN: achieved functionality \& limitations}
\label{sec:analyses:loading}

In this section is meant to assess to what extent Geofront's plugin loader mitigates the need for explicit configuration.
This analysis is based on the achievements and limitations explained by \refsec{sec:implementation:loading}.

\subsubsection*{To what extent does the plugin loader mitigate the need for explicit configuration of plugin libraries?}

Based on the results, we can state that the loader mitigates the need for explicit configuration only for the required, mandatory aspects. 
All optional properties like human-readable names and descriptions, must be specified explicitly using a naming convention specific to Geofront. 

In practice, however, there are some more "configuration" requirements. 
The limitations outlined by \refsec{sec:implementation:loading:limits} show that there are quite a few additional considerations. 
Geofront does not support all types or all library structures, and certain languages require additional compile limitations.

Also, while the optional properties are, well, optional, one could argue that some of these properties are in fact required. 
Libraries without 'human-readable' names and descriptions are harder to utilize on the Geofront Canvas.
While regular programming languages also allow the creation and publication of undocumented libraries, one can question if this should also be allowed for the more end-user focussed VPL libraries.

So, while the plugin loader can load some simple textual programming libraries almost without any special configuration, sizable libraries intended for consumption by Geofront will still need to be explicitly configured for Geofront.
However, even with these requirements, this can still be considered an improvement compared to the plugin systems of geometry VPLS studied at \refsec{sec:related-geovpl}, 
in which developers are required to create a class per exposed function.

\subsubsection*{Assess to what extent this creates seamless interoperability between textual programming libraries, and VPL libraries?}

Because of the reasons outlined above, it is safe to say that this seamless interoperability is only one-directional: Libraries intended for consumption by Geofront double as also a 'normal' javascript library. 
The configuration demands of Geofront only impair the normal, javascript-based usage by forcing a functional style, and by including certain methods only intended for Geofront. 
Even these Geofront-specific methods might prove useful in certain scenarios, such as by providing a way to visualize data.

This seamless interoperability is less prominent in the opposite direction. 
A normal javascript library, or a javascript library using WebAssembly, can't be automatically used by Geofront in most cases. 
Most libraries use incompatible types, or have an incompatible architecture.
In some cases, a library might be able to load, but is then functionality impaired by the interface. 
\reffig{fig:oop-considered-harmful} is an example of such a case.

\begin{figure}
  \centering
  \graphicspath{ {../../assets/images/6/3/} }
  \includegraphics[width=\linewidth]{ugly-oop.png}
  \caption[]{This typescript file technically loads correctly into Geofront, but cannot be reasonably used on the Geofront canvas. TODO: show what this looks like on canvas}
  \label{fig:oop-considered-harmful}
\end{figure}


