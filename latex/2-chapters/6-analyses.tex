\chapter{Analyses}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\label{chap:analyses}

In this chapter the various software implementations and design choices made in \refchap{chap:implementation} are analyzed. 
First, \refsec{sec:analyses:representation}.
Second, \refsec{sec:analyses:compilation}.
Then, \refsec{sec:analyses:loading}.
Finally, \refsec{sec:analyses:utilization}.

\section{The base application}
\label{sec:analyses:representation}

This section of the analysis covers the question of \mySubRQOneTitle, and aims in particular to answer the question: \emph{Per requirement, to what extend can core browser features be used to implement it?}.

We group the requirements listed at \refsec{sec:method-one} in a group of base features, a group of dataflow features, and a group of geometry features.

\subsection{Base VPL Features}

[Analyze the base implementation of geofront]
% [conclusion on implementation details]


\subsection{dataflow VPL Features}

% - disadvantages: 
%   - all in-between data must be stored in memory if it is to be inspected.
%     - Can't make use of 'writing files', so that something can be removed from memory 


\subsection{geometry VPL Features}


%   - The web is able to be used for geoprocessing, albeit with some caveats
%     - Less control and precision
%     - TypedArrays,
%     - Geometric predicates 
%     - Rounding
%     - ETC.

%  - Notes:
%    - would not be possible without these modern web features
%     - Web Assembly 
%     - Typed Array's 
%     - Web Workers
%     - Web Components,
%     - 2D Canvas API
%     - Web GL





Must have: 
\begin{enumerate}[-]
  \item a visual language
  \item an interface to configure this visual language 
  \item a representation of the 'variables' and 'functions' of the visual language
  \item a way to provide input data 
  \item a way to execute the language
  \item a way to display or save output data
\end{enumerate}

should have:
\begin{enumerate}[-]
  \item A method to preview 3D data used throughout the flowchart
  \item multiple ways to determine input data (text fields, sliders) 
  \item multiple ways to view output data (text displays, 3D viewers, etc.)
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

THE EVENTUAL ANSWER TO ALL OF THIS: 

The browser appears to be capable of representing a dataflow-type vpl graph to an acceptable degree, 
based on the implementation presented in \refsec{sec:implementation:representation}, and the analysis in \refsec{sec:analyses:representation}.
The browsers biggest advantage for an application like this is the sheer amount of features a javascript program can use by default, like the 2D canvas api and WebGL. 
These features do not need to be included within the source code of the application, leading to quick load times. 
All three of these features proved to be vital, and were performant enough to support an application like this. 
Only the 2D canvas Api can become slow when rendering a great number of components. 

JavaScript can also be used to represent the data structure and logic needed to make a VPL functional. 
Javascript's flexibility proved to be crucial to support advanced features like dynamically loading and using libraries at runtime. 
The disadvantage was due to JavaScript's very limited type support, and its limited precision in general. 
While the language does offers powerful options for reflection, this cannot truly be used if javascript itself makes no distinction between different number types (\m{int, float, double}) for example. 
The prototype-based objects also led to type-check problems. 
Typescript has been used to mitigate some of these shortcomings.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Compilation Process}
\label{sec:analyses:compilation}

REQUIREMENT: libraries containing pure functions exclusively
- no side effects, thats the whole point


HOWEVER 
- existing geo-libs: 
  - file IO focussed, (because of streaming \& big data)
  - templates
  - 




[Analyze the web-exposed geoprocessing libraries]

\subsection{First Experiment}

[Show the performance benchmarks in isolation. Also show them in action on the VPL canvas]

\subsection{Second Experiment}

The catch 21 between C++ and Rust.

\begin{note}

  **C++ -> wasm is difficult**
  
  - requires a lot of trivia knowledge. 
    - Often, many subdependencies need to be traversed, and makefiles need to be manually edited. 
    - This cannot be done often, or easely. 
  - Documentation is behind compared to Rust.

  - Libraries cannot be called. emscripten prefers a cli-type interface, and prefers you to write all the operations you wish to publish as separate command line applications. 

  https://www.hellorust.com/demos/add/index.html
  https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html


  **rust-> wasm is powerful and feature-rich.** 
  
  - it functions like a normal compiler. compilation was done easely. 
  - If a library cannot be compiled, the compiler statements are clear enough to identify which library causes the incompatibility. 
  - Many Rust libraries also conveniently offer a 'no-std' option, 
    And many crates (Rust equivalent of a library) include the web as one of their core targets. 
  - The compile tool 'wasm-bindgen' has excelent support for converting libraries. 
    - You can create rust libraries which from the outside look like a normal javascript library. 

\end{note}

\begin{note}
  where C++ requires emscripten, rust does that almost out of the box, (rustup target add wasm32-unknown-unknown)
  What we actually need to compare is not emscripten and wasm-bindgen, but 'embind' and 'wasm-bindgen'. 
\end{note}

\section{Loading plugins}
\label{sec:analyses:loading}

[Assess the plugin model]

% - to turn a function into a component usable in a visual programming graph, lots of meta-data is needed. 
% -> leading to config files 
% -> leading to a barrier between regular programming libraries, and vpl libraries. 
% -> this study opted for automated configs based on 'typescipt' headers to attempt to solve this problem. This worked, but had some new Limitations
%    -> it did allow for rapid experimentation, and seemless interoperability
%    -> however, other aspects like descriptions, library meta info, etc. 
%    -> for this a 'config' of some sorts was still needed. 

% Two layers of wrapper libraries are needed to take an existing rust / C++ library, and run it in a web-based visual programming language.

% This is why this third component of the methodology is focused on mitigating the need for the second wrapper library. 

% solutions: 
% - automatically base visual components on typescript header-files
% - add any 'config' information to the first type of wrapper library. 

% success: this works, albeit a bit hacky

\section{Usability}
\label{sec:analyses:utilization}

This section offers an analysis on the usability of Geofront, according to the framework described by \cite[]{green_usability_1996}.



\subsection*{\emph{Abstraction gradient: What are the minimum and maximum levels of abstraction? Can fragments be encapsulated?}}

Geofront was meant to support encapsulation. 
The need for re-using parts of a script as components / functions was deemed more important than the benefits of having no abstraction hierarchy (what you see is what you get).
An early prototype of Geofront did allow for encapsulation, by taking a subset of a Geofront script, and compiling it to a javascript subset. This could then be loaded by the library loader. 
However, the addition of special types of nodes, and features like iteration, invalidated the \m{geofront -> js} translator.
The translation is still possible, just not implemented.  
As such, if a user desires re-usable components and a lower abstraction level, they will need to write a Geofront library.

\textbf{Suggestion for improvement:} re-implemented the 'compile to js' procedure.

(image of abstracting away a javascript subset)



\subsection*{\emph{Closeness of mapping: What 'programming games' need to be learned?}}

Mapping a problem to a geofront script is intuitive for the most part.
Think of the operations needed to solve a problem, 
find the right libraries and nodes representing these operations,
and connect these nodes according to type. 
However, this mapping of problem and solution is hindered by the fact that Geofront needed to support iteration. 

(image of iteration problem)



\subsection*{\emph{Consistency: When some of the language has been learnt, how much of the rest can be inferred? }}

\cite[]{green_usability_1996} notes on the difficulty of defining 'consistency' in language design, and chose to define it as a form of 'guessability'.

Geofront has introduced certain symbolic distinctions between graphical entities to aid this predictability. 
The biggest is the distinction between \m{operation} and \m{widget} components: 
operations are pure functions with inputs and outputs. 
widgets represent some 'outside world' interaction, like an input value, a file, or a web service. 
This way, 'special behavior' is isolated to widgets, making the rest of the script more predictable. 

In practice, certain inconsistencies within Geofront arise due to the open nature of the plugin system. 
the consistency of geofront is mitigated by a library with a very different notion of naming, or if the library chooses unusual input or output patterns. 
For example, a euclidean, 3D coordinate can be specified as a \m{Vector3} object, a struct, an array of three numbers, or three different x, y, z input parameters.
Then again, it is unclear if inconsistencies between the api's of a language's libraries are to be contributed to the inconsistency of the language as a whole. 

\textbf{Suggestion for improvement:} Stabilize the api of the Geofront Standard Library.



\subsection*{\emph{Diffuseness: How many symbols or graphic entities are required to express a meaning? }}

Geofront periodically suffers from the same 'Diffuseness' problems \cite[]{green_usability_1996} adheres to vpls general. 
That is, sometimes a surprising number of 'graphical entities' / nodes are required to represent a simple statement.  
This is apparent when representing mathematical calculations. 

\begin{note}
  - the flowchart can only represent linear processes. Many geoprocessing algorithms are iterative and make use of conditionals. These cannot easily be expressed in a DAG VPL. As such, these processes must happen within the context of a function, within a 'computational node'  
\end{note}


(image of complex / simple mathematical calcluation in javascript and in geofront)

\textbf{Suggestion for improvement:} These situations could be prevented by allowing scriptable components. 

\subsection*{\emph{Error- proneness: Does the design of the notation induce 'careless mistakes'? }}

There are some errors the user can make  in Geofront that will not be immediately obvious. 
The biggest one is that there are no systems in place preventing large calculations. 
These might freeze up the application. 

To prevent this, the geofront interpreter should have been implemented to run on a separate thread, using a web worker. 
Besides this, in general, many systems are in place preventing errors, such as the type-safety used throughout geofront.
Also, by disallowing cyclical graphs, users cannot create infinite loops accidentally.

\subsection*{\emph{Hard mental operations: Are there places where the user needs to resort to fingers or pencilled annotation to keep track of what's happening? }}

Geofront is developed specifically to prevent "Hard mental operations".
Following the dataflow paradigm explained in \refsec{sec:background:dataflow}, geofront chose to disallows cyclical patterns. 
This greatly reduces the complexity of possible graph configurations, and also causes all in-between results to be immutable or 'final'.
By then allowing these results to be inspected, and allowing the graph to be easily reconfigured, Geofront allows a workflow rooted in experimentation and 'play'.
Users do not need to 'keep track' or 'guess' how things work.
Instead, they can simply experience the behavior, and adjust the behavior until satisfied. 



\subsection*{\emph{Hidden dependencies: Is every dependency overtly indicated in both directions? Is the indication perceptual or only symbolic? }}

The dimension of 'hidden dependencies' is another way the dataflow-paradigm is advantageous. 
The pure functions of a diagram-based vpl like Geofront make the language in general consistent and predictable.
However, there are two exceptions to this rule:
First, the \m{widget} nodes are allowed to produce side-effects, such as opening a window, asking for an input, making a web request, etc. 
These are required to provide geofront with interactive inputs and outputs.
The distinction between \m{widgets} and \m{}

And second, the pureness of functions can only be maintained if all Geofront libraries also exclusively use pure functions. 
There is no fail-safe in place to prevent the usage of a library containing functions with many side-effects. 

\subsection*{\emph{Premature commitment: Do programmers have to make decisions before they have the information they need? }}

In general, Geofront requires almost no premature commitment. 
Or, rather, the level of premature commitment is in line with textual programming languages, in the sense that a user is always somewhat committed to the structure they themselves build. 

One practical way in which Geofront exceeds in this dimension of premature commitment, is that the application does not require a restart upon loading a new library. 
Users can add or remove libraries "on the fly". 
This is unlike any vpl studied at \refsec{sec:related-geovpl} or \refsec{sec:related-webvpl}.

One particular type of commitment users must be aware off, however, is the commitment to using a \ac{vpl} like Geofront. 
Therefore, 


\subsection*{\emph{Progressive evaluation: Can a partially-complete program be executed to obtain feedback on 'How am I doing'? }}

Yes. 
As explained at the answer for the dimension of 'Hard mental operations', this is a core aspect in how Geofront achieves its interactivity and debugability, together with its ability to inspect parameters. 

(Image: Show example)

\subsection*{\emph{Role- expressiveness: Can the reader see how each component of a program relates to the whole? }}

as the authors of \cite[]{green_usability_1996} write: "The dimension of role-expressiveness is intended to describe how easy it is to answer the question 'what is this bit for?'"

sizeable phenomenon

grootste boosdoener: looping is now a simple boolean toggle within a component. 
This makes it very non-explicit, 

This leads to another problem: the problem of declarative iterations within a vpl. 


\subsection*{\emph{Secondary notation: Can programmers use layout, color, other cues to convey extra meaning, above and beyond the 'official' semantics of the language? }}

No, Geofront does not offer annotations in its current state, besides the way the nodes are configured on the canvas.  
Geofront does provide visual indicators for types, and for if a cable / variable represents a single item, or a list of items.

\textbf{Suggestion for improvement:} Provide a way to annotate: create groups, write comments, etc. 
\textbf{Suggestion for improvement:} Type colors would also be nice.

\subsection*{\emph{Viscosity: How much effort is required to perform a single change? }}

Despite these efforts, the 'mouse intensive' interface of vpls like Geofront continues to be a hinder for viscosity.
Certain situations require excessive mouse interaction, like substituting a function with another function, but keeping all inputs the same.
In text, this would be as simple as a non-symbolic renaming of the called function.
In geofront, this requires a lot of reconfiguration of cables. 

\textbf{Suggestion for improvement:} Viscosity could be improved by creating special actions in the editor to perform these types of manipulations.  
%  - select multiple inputs, select multiple outputs: connect by height.
% rename node


\subsection*{\emph{Visibility: Is every part of the code simultaneously visible (assuming a large enough display), or it it at least possible to juxtapose any two parts side-by-side at will? If the code is dispersed, is it at least possible to know in what order to read it?}}

All parts of the code are simultaneously visible. 
As the question implies, by not making the code dispersed, 

% ## Case Studies

% ### Vector
% _Vector data retrieval, transformation, visualization_

% ### Raster 
% _Raster data retrieval, transformation, visualization_

% ### 6. Experiments 
% _Performance benchmark between rust-wasm / cpp-wasm / cgal-cpp-wasm / js / cli usage_

% ## Final 
% _Answer research questions ????_


% \section{Experiments}

% \subsection{ Web Mapping Service }
% -> could work, must be captured in component
% -> streaming question

% \subsection{ Open Street Map }
% -> could be hooked up to the geojson viewer



% \section{ Performance }
% \subsection{Vector 3D}

% ....

% \subsection{Raster}

% ....

% \subsection{Geo features}

% ....


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Use Case: Educational Sandbox}
% \begin{lstlisting}
% WHAT: 
%  - show the behaviour of a simple ransac algorithm, fitting a plane through 
%    a point cloud
%  - show it beharivourly: show in-between steps
%  - make parameters ajustable (number of high scores, minimum high score, 
%    number of tries, etc.)
%  - add least squares adjustment, and compare.

% SIMILAR EXAMPLES: 
%  - the geometric predicates explanation 
%  (https://observablehq.com/@mourner/non-robust-arithmetic-as-art)
%  - 

% ASSESS ON: 
%  - educational value
%  - ease of usage (the promise of **Criterium A**)
 
% ASSESSMENT (hypothesis): 
%  + indeed very insightful for analying the behaviour 
%    and operation of certain 
%    algorithms & parameters. Not many applications can show 
%    this level of insight. 
%  + feature B can be used to strip the tool down 
%    to the bare minimum,   helping 
%    with not overwhelming the user with features

%  - This VPL is not easy to operate. 
%    It remains difficult to communicate what needs to 
%    be done, how things work. This is not an expert tool, 
%    but also not a beginners' tool.
%  - No built-in tutorialization
%  - hard to discover the code underneath, 
%    obfuscating the link between process and code.

% \end{lstlisting}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Use Case: Web Demo Environment}
% \begin{lstlisting}
%     WHAT:
%      - Show the startin delaunay triangulator
%      - Accept user-submitted Laz files as input
%        - filter the ground
%      - Accept a randomly generated point cloud based on perlin noise.
%      - Visualize the generated mesh, and make it available for download

%     EXAMPLES: 
%      - hugo's demo
    
%      ASSESS ON:
%      - **Criterium B**: extendability: 
%        - how does foreign and native codebases interact? 
%      - clarity
%      - reproducibility
%      - performance
%      - scope (raster / vector / 2D / 3D)

%     JUDGEMENTS (hypothesis): 
%      + Clarity is fine
%      + Reproducability is 
%      + Performance is decent

%      ~ clarity is fine, vpl allows users to 'play around' and try
%        different configurations, even run their own data through the
%        demonstrated functions

%      - Application is less suited for 2D 
    
% \end{lstlisting}


% \section{Use Case: Geoprocessing Environment}%%%%%%%%%%% SECTION
% \begin{lstlisting}

%     WHAT:
%       - Query an area of a point cloud with a polygon
%       - turn that area of points into a triangulation
%       - turn triangulation into isocurves
%       - save this as a geojson
%       - turn this whole thing into a function, which takes a PC, 
%         polygon and isocurve range, and spits out the geojson
%       - share this using a link
%       - turn this into an app?
%       - turn this into a script?

%     EXAMPLES: 
%      - 

%      ASSESS ON:
%      - **Criterium C**: Publicability:
%        - the ability to operationalize the application 
%        - can it be used by end-users? clarity? too much clutter

%     JUDGEMENTS (hypothesis): 
%       ~ sharing by link is possible, but for end-user usage, 
%         its very cluttered 
%       ~ compiling to js only partially works
%       ~ compiling into an app is not possible, but 
%         since everything runs client-side, it could be implemented. 

% \end{lstlisting}
