\chapter{Introduction}
The way maps are made is ever changing. Perhaps one of the most impactful ways this will change in the near future, is in the way described by the "Cloud Native Geospatial" vision. Proposed by the OGC, this movement envisions a future in which geodata storage and computation methods are re-imagined from the point of view of the cloud. 
It aims to radically simplify geodata storehouses to static servers, serving large, singular binary geodata files. All processing and analysis of this geodata can then be performed by separate cloud-based web services, which could then run containerized processes on an unprecedented scale, with unprecedented speed. 

% <!-- Why is it different, why does it ask for change? what type of change? -->
In order to make use of these advantages, both geodata storage and computation methods will need to be re-examined. 
Cloud computation and cloud-based data access ask for different priorities and features over native, desktop based alternatives. 
These features will either have to be added to existing formats and methods, or new substitutes formats and methods will need to be developed and tested.

% <!-- from cloud-native to vpl -->
This study regards the requirements for cloud-native \textbf{computation} in , and specifically from the point of view of geospatial visual programming environments. 

% <!-- Establish the VPL within geomatics -->
Within the field of geo informatics, Visual Programming environments (VPL)'s are popular interfaces for performing spatial analyses and geodata transformations. 
SaveSoft's FME (SOURCE) is a popular Extract Load Transform (ETL) tool for automating data integration, while McNeels's Grasshopper (SOURCE) is often used spatial analysis of buildings and cities, like solar irradiation. 
VPL's like these offers users a chance to interactively automate workflows \& processing pipelines, while requiring little to no programming knowledge. 
In between results can be inspected quickly, and the processes can be changed on the fly, often with immediate feedback.
This advantage of interactive, low-code automation is why the VPL continues to be a popular interface within the field of GIS, as well as all other use-cases in need of both low-code automation and visual debugging (Shader Programming, Procedural Geometry, CAD, BIM). 
A VPL done right can make automation available for a very large audience.

The cloud-native geospatial movement represents a significant opportunity and challenge to these VPL interfaces. The \textbf{opportunity} lies in the fact that a VPL interface is highly suitable as a 'configurator' or 'IDE' for cloud-computation. The promise of interactive, low-code automation matches the desire of most cloud native geoprocessing providers to support users of different backgrounds, both programmers and non-programmers, both full GIS experts as well as non-experts (SOURCE: Modellab, SOURCE: Chris Holmes). A good example of this is the ModelLab VPL, found in Raster Foundry (SOURCE). This is also evident in the fact that existing VPL's like FME and Grasshopper have added proprietary cloud-computation features like FME Cloud (SOURCE) and ShapeDiver (SOURCE), respectively.

% <!-- HOWEVERRRRRRRRR -->
However, the major \textbf{challenge} is that as of right now and despite these developments, popular VPL's fall short on a number of priorities and features required for cloud-native geospatial computation. 
These shortcomings include their closed and proprietary nature, their distance from regular programming features and conventions (git version control, continuous integration), and the non-containerized, one to one relationship between the IDE application \& the cloud hosting platform. All of this hinders their suitability as general, cloud-computation configurers. 

Sub component: FAIR: 
- FINDABLE:      Hard to find the right tools for the job
- ACCESSIBLE:    Hard to access these tools (install, setup environment, look at what you are doing)
- INTEROPERABLE: Hard to use two tools from different ecosystems (bindings, plugins, etc). 
- REUSABLE:      Hard to re-use a specific scripts written for one use case in another use case

% For a geoprocessing method to match the 'cloud native geospatial movement'

% Currently, WebAssembly is the only way one can take a geoprocessing function from an arbitrary source, and use it in both the browser and on a server. 
% We wish to discover if this has any practical use cases. 


\section{Research Objectives}
% Due to (this need for a re-examination of web features in relation to geo-computation), 
% the goal of this thesis is to develop an application for geo-computation in a browser-based front-end.

% This must be better 
\todo[]{Refine this part}

Due to this need for a vpl for cloud-native geo-computation, The goal of this thesis is to develop a new method for geo-computation in a browser-based front-end using WebAssembly.

This thesis presents the design, creation and evaluation of GeoFront, a web-based point-cloud processing tool. 
With GeoFront, geoprocessing flowcharts can be created, shared and run from within a web browser.  
The full application runs front-end in a browser, and both end results and intermediate products can be inspected in a 3D viewer.



% The tool offers functionalities such as point cloud loading, triangulation, and isocurve extraction.
% These functionalities can be expanded upon though a plugin system which utilizes the existing "Node Package Manager" infrastructure and WebAssembly.
% By using both, industry standard geoprocessing libraries such as `CGAL`, `GDAL` and `PROJ`, and data parsing libraries such as `IFC.js` and `laz-rs`, can be utilized.

% In addition to the goal of examining wasm-based geo-computation, the auxiliary goal of this thesis is to make geoprocessing more accessible. 
% By being free and open source, usable in a browser, and by focussing on the integration of existing geoprocessing libraries, GeoFront attempts to be more in line with the wider vision of cloud-native Geospatial than visual geo-computation environments, like FME or Grasshopper. 
% This is done to be in line with the aforementioned cloud native vision of eventually allowing non-expert usage of GIS.


% This design of geofront contains several challenges. Browser-based geo-computation (BBGC) might not be as performant as back-end / native geo-computation \cite{panidi_hybrid_2015, hamilton_client-side_2014}, even with the usage of WebAssembly \cite{jangda_not_2019}. 
% Additionally, since current visual programming environments all fall short on at least one of the above features, the visual programming environment will have to be created from scratch.

\newpage
\section{Research Questions}
Based on these objectives, the research question is formulated as follows: 

\textit{"Can a web-vpl make point-cloud computations more FAIR?"}

\subsection*{Sub Questions}
The following sub-research questions are needed in order to answer the main question. 

\todo[]{Maybe translate this to 'how' questions: "How can X make Y more Findable?"}

\begin{enumerate}[a]
  \item Does the format of web application make point-cloud computations more \emph{Findable}?  
  \item Does the format of a visual programming language make point-cloud computations more \emph{Accessible}?  
  \item Do point-cloud geoprocessing libraries become more \emph{Interoperable} when compiled to WebAssembly?  
  \item Does the ability to compile a VPL script to javascript make those VPL scripts more \emph{Reusable}?  
\end{enumerate}

\newpage
\section{Scope}
The scope of this thesis is defined in the following ways: 


\subsection*{ No back-end WebAssembly } 
This study will limit itself to the \emph{front-end} usage of WebAssembly. This looks contradictory to the goal of cloud-native geo-computation, and thus requires explanation.

While this is a prerequisite for cloud-native geospatial processing, is not necessarily needed to run code in the cloud in order to test ideas and methods of containerization. 
Instead, this study investigates containerized, FAIR geoprocessing as an exercise alone.  


This study choice the browser front-end, because it serves as a good proxy for containerization:
By making a traditionally native process run in a front-end web environment, it is safe to assume can also be run on a server. 
Additionally, by developing not just a method but also a full application, the method can be tested not only based on theoretical properties, but on actual applicability to use-cases as well. 

Still, back-end containerized geoprocessing would be an excellent follow-up investigation to this study. 

\subsection*{ No Web Processing Services } 
Similarly, this study will exclude the OGC standard of the \ac{wps} \cite{ogc_web_2015}, since these services do not offer \emph{front-end} geoprocessing, but instead offer \emph{back-end} side geoprocessing. A client-side application \textit{could} create an interface to use such a service, to essentially offer geoprocessing to clients, but this study regards a solution like that as a workaround, not a true solution to the problem of client-side geoprocessing. 

This is not to say that client-side geoprocessing replaces the need for \ac{wps}. 
future work could research the possibility of utilizing a hybrid strategy of both client-side and server-side geoprocessing, following in the footsteps of \cite{panidi_hybrid_2015}. 

\subsection*{ No Usability Analysis } % 
\todo[]{Is this still true in this new thesis?}
While accessibility / usability is a motivation of this research, no claims will be made that the developed use-case is more usable to native GIS applications or geoprocessing methods. This research attempts to solve practical inhibitions in order to discover whether or not client-side is \emph{a} usable option. If it turns out that this method is viable technically, future research will be needed to definitively proof \emph{how} usable it is compared to all other existing methods.  

% This paper seeks to first close this gap, limiting itself to overcoming the technical and design boundaries in the pursuit of practical client-side geoprocessing.

Similarly, a survey analyzing how users experience client-side geoprocessing in comparison to native geoprocessing must also be left to subsequent research. While this would gain us a tremendous amount of insight, client-side geoprocessing is too new to make a balanced comparison. Native environments like QGIS, FME or ArcGIS simply have a twenty year lead in research and development. 

% It is my goal to introduce this as a new geoprocessing option, and to name the advantages and disadvantages we can be sure of. An actual comparison of client-side vs native geoprocessing is something different. 


\subsection {Only WebAssembly, no Docker}
This thesis examines a WebAssembly based approach to containerization. Approaches using Docker are not covered, and are left to subsequent research.

\subsection*{ Only 3D Vector / Point Cloud geoprocessing}
Geoprocessing, or geo-computation, is a sizable phenomenon. 
It covers all operations on geodata, from 2D rasters, 2D \& 3D vector data, tabular datasets, and point clouds. 
Due to time limitations, we are forced to provide one focus on particular type of geoprocessing
- raster
- table / 2D features

\subsection*{ Only core browser features }
GeoFront will be designed and constructed using only core browser features. 
- Only using basic HTML5 features.
- The research objective is to explore core web features, not to examine the front-end web ecosystem. 
- name all html things

\subsection*{ Visual Programming }
The format chosen for the demo application GeoFront is a visual programming language. Visual programming has the advantage 

\section{Guide}

As such, the study first describes the design and implementation of GeoFront, and then evaluates the tool to various geo-computation use cases.
The advantages and disadvantages of browser based geo-computation, compared to native or server-side geo-computation, are examined in several scenario's. 
Both quantitative indicators, like loading and runtime performance, as well as qualitative indicators, like the fitness for an intended use-case, are measured in each of these cases.