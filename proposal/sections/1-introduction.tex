%-------------------------------------------------------------------------------------------------%
% An introduction in which the relevance of the project and its place in the 
% context of geomatics is described, along with a clearly-defined problem statement.
% [KEN]
% instead, I think you can start by saying that web applications are popular
% explain the benefits briefly
% apart from having no installation

% then, I think you can make a better argument for your thesis overall
% explain that historically, thin client fat server was the standard
% for the reasons you listed
% and then directly explain why this is potentially changing now

\newpage
\section{Introduction}

% Dissolving the discrepancy between visualization \& processing in web-apps.

% web is popular 
% geoweb-applications are popular 
% online geodata processing is popular 
% client-side geodata processing 

Interactive, browser-based \ac{gis} applications form an indispensable component of the modern geospatial software landscape. These Web applications are cross-platform in nature, and offer ease of maintainability and access since no installment or app-store interaction is required before updating or running them. The ability be placed as a supplement within the larger context of a web-page is also not trivial. These features have made the browser a popular host for many \ac{gis} applications, especially when targeting end-users. 

Despite the popularity of these types of applications, the range of \ac{gis} abilities these applications are capable of are often very limited. Current geospatial web applications serve mostly as lightweight viewers; visualizers of pre-processed data. \ac{geoprocessing} capabilities, like CRS translations, interpolation, boolean operations, or raster transformation kernels are usually not present within the same environment as these applications. 

These utilities do exist in the form of \ac{wps}. By uploading input data to a \ac{wps}, polling its status, and then downloading the results once finished, geodata can be processed on a server. This is an excellent solution in situations where client-side hardware is limited, and server-side resources are abundant. When the reverse is true, however, and when the application needs to remain interactive and responsive, other solutions are required.

The improvements of client-side hardware have opened up a different possibility: client-side geoprocessing, directly within a web application. By doing this, the hard divide between client visualization and server processing could be bridged. This would allow a new range of interactive web applications, in which users can post-process geodata quickly, uniquely, and on demand, while at the same time driving down the operational costs of geoprocessing servers. This is why client-side \ac{geoprocessing} in web applications is slowly gaining traction during the last decade \cite{kulawiak_analysis_2019, panidi_hybrid_2015, hamilton_client-side_2014}. 

% Interactive geospatial data manipulation and online geospatial data processing techniques are described as "current highly valuable trends in evolution of the Web mapping and Web GIS" \cite{panidi_hybrid_2015}. 

However, serious drawbacks to client-side geoprocessing where encountered during these studies.  
Browser-based geoprocessing suffers from the fact that it will need to be written in the `JavaScript` programming language. 
Previous attempts at client-side geoprocessing have shown that JavaScript based geoprocessing libraries do not offer the performance required for proper geodata processing \cite{hamilton_client-side_2014}. 
Moreover, the JavaScript library ecosystem does not offer viable alternatives to industry-standard libraries like CGAL and GDAL. 
% This would require alternatives to be rewritten in JavaScript, or would require the source code of mature libraries to be compiled to JavaScript. Both these solutions would be difficult to maintain, and would still end 
% Both these solutions contain many imperfections. The first option would be an inefficient, time-consuming task, and would mean code duplication. 
% The second option would mean taking C++-based libraries such as CGAL, and compiling them to a special, fast subset of JavaScript called `asm.js` using the `emscripten` compiler \cite{zakai_emscripten_2011}. 
% While this is more fast and reliable, it contains its own set of problems. 
% The generated, rather large JavaScript files usually take a long time to download, to scan, and to be properly optimized by a JavaScript Just In Time (JIT) Compiler \cite{haas_bringing_2017}. 

An emergent technology poses a solution to both problems. At the end of 2019, the \ac{w3c} officially pronounced WebAssembly as the fourth programming language of the web \cite{w3c_world_2019}. Since then, all major browsers have added official WebAssembly support. \ac{wasm} is a binary compilation target meant to be small, fast, containerized, and platform \& source independent \cite{haas_bringing_2017}. \ac{wasm} surpasses javascript in almost all performance aspects: it loads quicker, it is scanned quicker, and since it is close to bytecode, it can often run at a speed comparable to system level programming languages like C++ and Rust \cite{jangda_not_2019}. 

% \cite{beilschmidt_vat_2017}


% Related studies concerned with the performance of WebAssembly, together with the existing software around WebAssembly, pose enough evidence to suggest  theoretically possible (SOURCE: Emscriptem). 
% However, this leaves the question whether it is practically possible unanswered, evident by the fact that no wasm-powered geoprocessing tools exists at the time of writing this study. 

\newpage

\subsection{Problem}

If WebAssembly performs as described by \cite{haas_bringing_2017} and \cite{jangda_not_2019}, it could theoretically be the missing link to make client-side geoprocessing viable. However, no wasm-powered geoprocessing tools exists yet at the time of writing. Hypothetically, this is because of two reasons. Firstly, WebAssembly brings along many practical considerations which remain unanswered:

\begin{itemize}
  \item Do geoprocessing libraries directly compile into WebAssembly? If not, which workarounds are needed? 
  \item Will a \ac{wagl} load efficiently, or should they be split up into parts, and loaded lazily? 
  \item How well do \ac{wagl} operations perform in a browser, compared to their native counterparts? What can be done to make this difference as small as possible?
\end{itemize}

Secondly, the above list of practical implementation details cover only how \ac{wagl}'s can be \emph{run}. Potential answers do not indicate how \ac{wagl}'s can be \emph{used}. \cite{jangda_not_2019} warns against assessing WebAssembly in a vacuum, and notes how its performance is highly dependent on the way it is used, and the context in which it is used. This context of geoprocessing within a web-browser brings up many considerations as well: 

\begin{itemize}
  \item How will users upload or specify the input in a web-browser?
  \item Can the transformations offered by \ac{wagl}'s be used like functions? Or do they require special services, such as a wrapper library, virtual file system, or a virtual Command line interface? 
  \item How can users recieve and evaluate the output in a web-browser?
  \item How can a sequence of geoprocessing steps be chained together in a web-browser?
  \item How can a web-based \ac{ui} or \ac{gui} facilitate all these functionalities?
\end{itemize}

These two sets of considerations are highly dependent upon each other. Together, they form a barrier preventing further development of client-side geoprocessing. Since no wasm-powered, client-side geoprocessing application exist yet, there is no way to answer these questions, and no way to confirm the theoretical benefits of WebAssembly for client-side geoprocessing, and the geospatial community at large.


%-------------------------------------------------------------------------------------------------%
\newpage

%-------------------------------------------------------------------------------------------------%
\subsection{Research Questions}

This study intends to discover if contemporary web technologies can facilitate client-side geoprocessing by seeking an answer to the following question:  

\textit{How to \textbf{design and create} a browser-based GIS environment which can \textbf{effectively utilize} \textbf{existing geoprocessing libraries}, using only the \textbf{current state} of \textbf{standard client-side web technologies}?}

\subsubsection*{Explanation}

% The research question is written purposefully written in the "how well does X support Y question" shape. To unpack its components: 

- \textbf{design and create}: The wording 'design and create' is used to signal that this will consider the theoretical design , as well as the practicalities of creating this design. 

- \textbf{Standard client-side web technologies}: This phrase is meant to limit the scope to only the standard, core technologies of major browsers (Chrome, Edge, Safari, Firefox). This means the four languages \ac{wasm}, CSS, JavaScript and HTML. Additionally, HTML5 gives us WebGl, the 2d Canvas API, SVG's, and Web Components to work with.

- \textbf{Current state}: The study will use contemporary, even bleeding edge features of the modern web, but its findings will nonetheless be bound to this time of writing, as web technologies in particular quickly change. 

- \textbf{Existing geoprocessing libraries}. This wording expresses this studies desire to explore the usage of existing geoprocessing libraries, rather than to recreate geoprocessing libraries from scratch.

- \textbf{Effectively utilize}: The study intends to not only find out how \ac{wagl}'s can be \textit{run} in a browser, but also how \ac{wagl}'s can be \textit{used}. 


\subsubsection*{Sub Questions}

The following sub-research questions are needed in order to answer the main question. The methodology chapter will explain the choices of these sub-questions. 

\textit{1 : What is the most fitting methodology of compiling C++ geoprocessing libraries to WebAssembly?}

\textit{2 : How to design and create a client-side geoprocessing interface for data-users?}

\textit{3 : How can wasm-compiled geoprocessing libraries be distributed and used in a client-side geoprocessing interface?}

\textit{4 : What are the advantages and disadvantages of GIS applications created using a client-side geoprocessing environment powered by WebAssembly?}


\subsubsection*{Assessment}

At the final conclusion of the proposed thesis, we can answer if the designed and created GIS environment can indeed effectively utilize these geo-libraries.
this will be answered by quantitative and qualitative means:

Quantity
\begin{itemize}
    \item Have all required features been implemented?
    \item Which libraries can be used?
    \item What are the load \& run times of these libraries, compared to native execution?
\end{itemize} 

Quality
\begin{itemize}
    \item Have all design goals been met?
    \item Can data users 'effectively' handle input, process and output?
    \item Can the load \& run times be regarded as acceptable to use? 
\end{itemize} 


% ----
\subsection{Scope}


\subsection*{Will Include}

The 'will include' scope is represented by the Methodology chapter. 

%-----------------------------------------------------------------------------%
\subsection*{Will not include}

\subsubsection*{Server-side WebAssembly} % **Client-side WebAssembly Only**

This study will limit itself to the \emph{client-side} usage of WebAssembly. 
A powerful case can be made for \emph{server-side} usage of WebAssembly, especially in conjunction with a programming language such as Rust. 
Rust compiled to WebAssembly could, compared to using python, java or C++, make geoprocessing more maintainable and reliable, while at the same time ensuring memory safety, security, and performance \cite{clack_standardizing_2019}. 
Server-side wasm is beyond the scope of this paper, but would be an excellent starting point for future work. Note that this also means that research into \ac{wagl}'s is important for more than just client-side geoprocessing. All geoprocessing could benefit from it.



\subsubsection*{Web Processing Services} % Will not be dealing with WPS 

% offered as server-side geoprocessing services.  

This research will exclude the OGC standard of web processing services \cite{ogc_web_2015}, since these services are not about \emph{client} side geoprocessing, but instead cover \emph{server} side geoprocessing. 
Future work could, however, research the possibility of utilizing a hybrid strategy of both client-side and server-side geoprocessing, following in the footsteps of \cite{panidi_hybrid_2015}. 



\subsubsection*{Usability Analysis} % 

While usability is a major component of this research, no claims will be made that the developed geoprocessing environment is more usable to native GIS applications or geoprocessing methods. This research attempts to solve practical inhibitions in order to discover whether or not client-side is \emph{an} usable option. If it turns out that this method is viable technically, future research will be needed to definitively proof \emph{how} usable it is compared to all other existing methods.  

% This paper seeks to first close this gap, limiting itself to overcoming the technical and design boundaries in the pursuit of practical client-side geoprocessing.

Similarly, a survey analyzing how users experience client-side geoprocessing in comparison to native geoprocessing must also be left to subsequent research. While this would gain us tremendous insight, client-side geoprocessing is too new to make a balanced comparison. Native environments like GRASSGIS, QGIS, FME or Esri simply have a twenty year lead in research and development. 
