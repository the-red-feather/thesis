

\section{Preliminary Work}

As visualized in \reffig{fig:method}, two steps of this proposed methodology has already been carried out: A small-scale wasm application, and the basics of a browser-based visual programming language. These where both part of the preliminary work done in preparation of this thesis proposal. This chapter will elaborate upon these works.


\subsection*{Wasm Application}

WebAssembly is a major component of this proposed thesis. However, the compilation target is still widely regarded as being "bleeding edge" (FIND SOURCE). This makes it all the more vital to gain some level of experience using the compile target before using it in more complicated scenario's. 

The Geomatics curriculum this thesis proposal is part of, offers a subject called "Research Assignment". This course offers students to gain experience in a geomatics-related topic of choice, and this made it the perfect context to try out WebAssembly for a geomatics web application.

The assignment given was to deliver a prototype for an online cityJSON validator. 
WebAssembly was to be used to perform a very fast JSON schema check over a user submitted json, among other things. 
This assignment was carried out successfully, and the delivered prototype (\reffig{fig:cjval-prototype}) played a role in the official CityJSON validator (\reffig{fig:cjval-official}), which uses WebAssembly. 

\begin{figure}[!tbp]
    \centering
    \begin{minipage}[b]{0.45\textwidth}
      \includegraphics[width=\textwidth]{../images/cjval-prototype.PNG}
      \caption{The prototype}
      \label{fig:cjval-prototype}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\textwidth}
      \includegraphics[width=\textwidth]{../images/cjval-official.PNG}
      \caption{The official validator}
      \label{fig:cjval-official}
    \end{minipage}
\end{figure}


Creating this application was very insightful. I would like to point out a few key insights, which will undoubtedly play an important role in the proposed thesis: 

\begin{itemize}

    \item The language this application was compiled from was Rust, not C++. Rust offers first-hand WebAssembly supports, as its default compiler supports WebAssembly. Surrounding tooling like \textit{wasm-pack} and community support \& tutorials made using WebAssembly within web applications very doable. 
    C++ will still be used in the proposed thesis for the sake of compiling existing libraries, but if the necessity arises to write custom WebAssembly components, Rust will be preferred, taking advantage of these aspects, and the fact that wasm can integrate multiple languages.

    \item It was very interesting to discover how WebAssembly supports a hybrid gui + cli setup. 
    The assignment was carried out by first developing a native Rust CLI-application which can be used as a standalone validator. 
    This code was then 'wrapped' as an api, and together with \textit{wasm-pack}, exposed and integrated within a website. 
    The advantage this offers is synergy between CLI and GUI. Any change made or feature added to the original application can easily be integrated within the web-exposed application. It also makes sure that a user can choose what interface they prefer. 

    % TODO diagram 

    \item The resulting application is extremely fast. It is one thing to theorize about performance gain, and another thing to experience it, and what it means for the usability of an application. The validation was often just as fast as the native binary application, and sometimes, for reasons not yet discovered, WebAssembly was even faster. When you start comparing this speed to other web-based json validators, this performance gain is even more apparent. A process which normally takes minutes now completes within a second. 

    % (TODO: maybe speed comparrison of https://jsonschemalint.com/#!/version/draft-07/markup/json
    % vs https://validator.cityjson.org/)

\end{itemize}


\subsection*{VPL Prototype}

The question of what a FAIR geoprocessing interface should look like was the topic of a second preliminary study. 

% bit out of scope so do it beforehand

An interface in the shape \ac{vpl} was chosen for several reasons:

\begin{itemize}
  \item A \ac{vpl} can be seen as a compromise between a programming language and a full \ac{gui}. This has the advantage of serving both geodata experts, as well as the "data user" group depicted by \cite{brink_geospatial_2018}. The latter group might not be prepared to code, but would like to chain together geodata processing functions.
  \item \ac{vpl}'s have a clear advantage when dealing with data containing a visual component. Even programmers often use \ac{vpl}'s when programming shaders, for instance. Making in-between steps graphically debugable is very difficult to do with regular programming languages.  
  \item Geodata processing experts often depict geodata pipelines as a flowchart, graph, or a literal pipeline. 
\end{itemize}

Using a \ac{vpl} for geodata processing, or geometry manipulation in general is not uncommon. To name a few: 



Author of one of these applications states that these where the reasons for development: 
% \cite{RAVI}

This paper also states the cognitive advantages 

% Lots of research has been done on the topic of VPL's, and their advantages and disadvantages. 
% (I explicitly want to name the cognitive dimentions paper, it is very good and appropriate, and contains many suggestions for future VPL's)



\subsubsection*{Geofront}

This is how the development of this \ac{vpl} came to be

- early build -> only booleans
- blocks can be chained together
- blocks can be compiled to javascript
- this javascript can be put in a block, composing higher-order algorithms
- 