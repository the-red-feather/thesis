\chapter{Implementation}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CHAPTER

\section{Software Architecture}

\emph{Explain full scope}

% # 4. SOFTWARE IMPLEMENTATION
% <!-- Show how one might rewrite this -->

\emph{Explain main code setup \& components}
The Geofront codebase ...

\subsection{Web Framework}
\emph{explain how to create a web framework from scratch}
- No Framework
- Web Components
- Typesave Events
- Webpack + Typescript

"...
WebComponents have not been used just as a curiosity. 
The Graph is intended as a sequence of containerized processes, which whould match WebComponents containerized nature perfectly, just like it matches WebAssembly
..."


\subsection{Menu}
with these html components, the basics of the webapp can be created: menu's side menu, and the two main canvases: the graph canvas, and the viewer canvas 
% _explain the file / edit / view / side menu setup_  (Because of Design rule 1. Model after normal application )

\section{The Graph}
\emph{explain how to create a visual programming language}
\subsubsection*{Graph representation}
  - Map `Functions` to `Nodes` 
  - Map `Variables` to `Edges / Cables`
\subsubsection*{Graph manipulation}
  - Canvas 2d API
  - Event-driven
\subsubsection*{Graph calculation}
  - Dag
  - Dynamic recalculation 

\subsection{Viewer}
\emph{explain how the viewer was created from scratch}

lightweight three.js clone

supports basic things

fast, due to direct buffer types

\subsection{ Plugin Loader } 

\emph{explain the system to dynamically load plugins at runtime}

\subsubsection{ Type System }

\emph{explain how data is exchanged, and objects are handled (lazy tools)}
- Functional programming (exchange structs)

\subsection{ Standard Library }

The standard library is a 'baked in plugin'.
Points, lines, triangles, vectors, etc.

\subsection{ Plugins }
What does a plugin need in order to be acceptable
one javascript file, one type definitions file, and one optional wasm file are accepted. 

ts -> normal build works out of the box
rust -> wasm pack compile target web -> works out of the box 
c++ -> emscripten -> more manual work needed 

\subsubsection{Features}
- IO can use:
  - basic types (boolean / number / string)
  - jsons, objects, interfaces (typesystem will pick up on them)
  - ArrayBuffers (vital for performant data transfer)



% ## WebAssembly Plugins

% _explain how to use webassembly_
% - compiling
% - getting data within webassembly
% - extracting webassembly
% - how to deal with objects? 


\subsubsection{ Startin }
- web assembly based

\subsubsection{ CGAL }




\section{Achieved Functionality}

...




